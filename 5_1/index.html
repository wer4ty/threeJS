<!DOCTYPE html>
    <html>
        <head>
            <title>Create 3D Terrain</title>
            <script src="../lib/three.js"></script>
            <script src="../lib/dat.gui.min.js"></script>
            <script src="../lib/stats.min.js"></script>
            <script src="../lib/chroma.min.js"></script>

            <style>
            body {
                /* set margin to 0 and overflow to hidden, to go fullscreen */
                margin: 0;
                overflow: hidden;
                }
            </style>
        </head>
      
<script type="text/javascript">
	
	// global vars
	let MAX_HEIGHT = 6;
	var renderer;
	var scene;
	var camera;
	var stats, control;

	let scale = chroma.scale(['blue', 'green', 'red']).domain([0, MAX_HEIGHT]);


	function init() {


		// init code
		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera(
			45, window.innerWidth / window.innerHeight, 0.1, 1000);

		renderer = new THREE.WebGLRenderer();
		renderer.setClearColor(0x000000, 1.0);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMapEnabled = true;

		
		camera.position.x = 40;
		camera.position.y = 40;
		camera.position.z = 50;
		camera.lookAt(scene.position);

		let spotLight = new THREE.SpotLight(0xffffff);
		spotLight.position.set(10,100,10);
		scene.add(spotLight);
		scene.add(new THREE.AmbientLight(0x252525));

		control = new function() {
			this.toFaceMaterial = function(){
				let mesh = scene.getObjectByName('terrain');
				let mat = new THREE.MeshLambertMaterial();
				mat.vertexColors = THREE.FaceColors;
				mat.shading = THREE.NoShading;
				mesh.material = mat;
			};

			this.toNormalMaterial = function() {
				let mesh = scene.getObjectByName('terrain');
				let mat = new THREE.MeshNormalMaterial();
				mesh.material = mat;
			};
			this.smoothShading = false;

			this.onSmoothShadingChange = function() {
				let material = scene.getObjectByName('terrain').material;
				let geom = scene.getObjectByName('terrain').geometry;

				if (this.object.smoothShading) {
					material.shading = THREE.SmoothShading;
				}
				else {
					material.shading = THREE.NoShading;
				}
				material.needsUpdate = true;
				geom.normalsNeedUpdate = true;
			}
		}

		addControlGui(control);
		addStatsObject();

	
		document.body.appendChild(renderer.domElement);

		render();
	}


    function addStatsObject() {
    	stats = new Stats();
    	stats.setMode(1);
    	stats.domElement.style.position = "absolute";
    	stats.domElement.style.left = '0px';
    	stats.domElement.style.top = '0px';
    	document.body.appendChild(stats.domElement);
    }

	function render() {

		stats.update();

	
		requestAnimationFrame(render);

	}



	function handleResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}


	function maze_init() {
		var maze = new Maze(document, 'maze');
		maze.generate();
		maze.draw();
	}

	window.onload = maze_init;

	window.addEventListener('resize', handleResize, false);
	
</script>

<body>
 <canvas id="maze" width="400" height="400"></canvas>

</body>

</html>
